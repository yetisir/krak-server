import krak

scene = krak.Scene()

sphere = krak.Sphere()
cone = krak.Cone()
#cad = krak.Surface(file='pit_shell.stl')

# sphere.translate(distance=1, direction='up')
# cone.translate(distance=1, direction='down')
# cad.show = False




Skip to content
 
Search…
All gists
Back to GitHub
Sign in
Sign up
Instantly share code, notes, and snippets.

@brandonwillard brandonwillard/assign_caching.py
Created 2 years ago
00
 Code Revisions 1
<script src="https://gist.github.com/brandonwillard/165d5e1e409556f075b841bcc00c938e.js"></script>
  
Python AST-based Caching
 assign_caching.py
  import inspect
  import shelve
  import ast

  from itertools import cycle


  class AssignCachingVisitor(ast.NodeVisitor):
      """Slightly less naive src block caching.
      TODO: Create a simple dependency graph so that we can invalidate
      cache items from other blocks.
      """

      def __init__(self, cache_file, debug=False):
          """
          Parameters
          ==========
          cache_file: str, or file-like object
              The cache file used by `shelve`.
          """

          self.db = shelve.open(cache_file)
          self.debug = debug

          try:
              self.locals = inspect.stack()[1][0].f_locals
          except Exception:
              raise ValueError("Cannot obtain caller's locals")

      def _var_cache_id(self, name_symbol):
          if self.code_context_id:
              return '{}-{}'.format(self.code_context_id, name_symbol.id)
          else:
              return name_symbol.id

      def _get_vars_and_vals(self, node):
          for var, val in zip(node.targets, cycle([node.value])):
              if isinstance(var, ast.Tuple):
                  vars_vals = [(v, w) for v, w in zip(var.elts, val.elts)]
              else:
                  vars_vals = [(var, val)]
          return vars_vals

      def visit_FunctionDef(self, node):
          # TODO: When building a dependency graph, find assignments to
          # tracked variables within functions.
          # for cnode in ast.iter_child_nodes(node):
          #     if isinstance(node, ast.Assign):
          #         pass
          pass

      def visit_AsyncFunctionDef(self, node):
          # self.visit_FunctionDef(node)
          pass

      def visit_ClassDef(self, node):
          # TODO: Check outside assignments from within class methods?
          # self.visit_FunctionDef(node)
          pass

      def visit_Assign(self, node):
          vars_vals = self._get_vars_and_vals(node)

          for var, val in vars_vals:

              exists_var_local = var.id in self.locals
              # self.locals.get(var.id, None)
              var_cache_id = self._var_cache_id(var)

              if var_cache_id not in self.db:
                  # Execute the code and add variables to the cache.
                  if not self.dirty:
                      co = compile(self.base_node, "<ast>", 'exec')
                      exec(co, self.locals)
                      self.dirty = True

                      if self.debug:
                          print('Executed code.')

                  self.db[var_cache_id] = self.locals[var.id]

                  if self.debug:
                      print('Added {} to cache with cache id {}'.format(var.id, var_cache_id))

              elif not self.dirty and not exists_var_local and var_cache_id in self.db:
                  # Add missing variable to local environment
                  cache_val = self.db[var_cache_id]
                  self.locals[var.id] = cache_val

                  if self.debug:
                      print('Added {} from cache with cache id {}'.format(var.id, var_cache_id))

              elif not self.dirty and exists_var_local and var_cache_id in self.db:
                  # Variable already exists (not due to us executing the source) and is in the cache.
                  if self.prefer_cache:
                      self.locals[var.id] = self.db[var_cache_id]

                      if self.debug:
                          print('Updated local value (using cache value) for cache id {}'.format(var_cache_id))

                  elif self.update_cache:
                      self.db[var_cache_id] = self.locals[var.id]

                      if self.debug:
                          print('Updated cache value (using local value) for cache id {}'.format(var_cache_id))

      def run(self, node, code_context_id=None, prefer_cache=False, update_cache=False):
          """
          Parameters
          ==========
          code_context_id: str (None)
              An identifier applied to symbol names.  Allows for code-block-specific/historical
              caching.
          prefer_cache: bool
              Use the cached value when a variable exists locally and in the cache.
          update_cache: bool
              Update the cache value when a variable exists locally and in the cache.
              `prefer_cache` must be `False` for this to take effect.
          """

          self.code_context_id = code_context_id
          self.base_node = node
          self.dirty = False
          self.prefer_cache = prefer_cache
          self.update_cache = update_cache

          self.visit(node)
 assign_caching_demo.py
  import tempfile


  cache_file = tempfile.mktemp(suffix='.db', dir='/tmp')

  code_str = '''
  print("hi")
  x = 1
  q = 3
  def blah(y, b=32):
      res = y + b
      # Assigning a var out of scope.
      q = 30
      return res
  class Bloh(object):
      some_field = 0
      def some_method(self, q=1):
          # This `q` is different.
          q += 8
          method_res = q + 3
          # Assigning a var out of scope.
          x = 20
          return method_res
  # l = blagh()
  z = blah(x)
  x += 1
  c, d = [1, 3]
  z = blah(x, b=80)
  '''

  code_ast = ast.parse(code_str)

  exec(code_str)

  acv = AssignCachingVisitor(cache_file)

  try:
      del x, q, z, c, d
  except Exception:
      pass

  acv.db.clear()

  assert len(list(acv.db.keys())) == 0

  # This run should mark the cache as dirty and add all assigned variables.
  acv.run(code_ast)

  assert acv.dirty
  assert set(acv.db.keys()) == set(['x', 'q', 'z', 'c', 'd'])

  # This run should run no code.
  acv.run(code_ast)

  assert not acv.dirty

  del x

  # This run should find that `x` is missing and add it back into the session.
  acv.run(code_ast)

  assert not acv.dirty
  assert 'x' in locals()
 to join this conversation on GitHub. Already have an account? Sign in to comment
© 2020 GitHub, Inc.
Terms
Privacy
Security
Status
Help
Contact GitHub
Pricing
API
Training
Blog
About
